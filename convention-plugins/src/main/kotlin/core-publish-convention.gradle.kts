plugins {
    id("org.gradle.maven-publish")
}

// Apply the extension
val publishingExtension: utils.PublishingExtension = extensions.create("publishingConfig", utils.PublishingExtension::class)

afterEvaluate {
    // artifact (from module build.gradle)
    val groupName = publishingExtension.groupId ?: project.property("groupName") as String
    val versionName = publishingExtension.version ?: project.property("versionName") as String
    val libraryName = publishingExtension.artifactId ?: project.property("libraryName") as String
    // project info (from module build.gradle)
    val projectGithubUrl = publishingExtension.projectGithubUrl ?: project.property("projectGithubUrl") as String
    val projectDescription = publishingExtension.projectDescription ?: project.property("projectDescription") as String
    // misc
    val packingOption = publishingExtension.packagingOption
    val includeSources = publishingExtension.includeSources
    // developers (from gradle.properties)
    val developerId: String by project
    val developerName: String by project
    val developerEmail: String by project
    val developerOrganisation: String by project
    val developerOrganisationUrl: String by project

    // This creates a task called `sourcesJar`. It subclasses `Jar`, which is a
    // task that knows how to copy files into a .jar file. The block after it is
    // called the configuration, which tells the task what it should do when run.
    val sourcesJar = tasks.register("sourcesJar", Jar::class) {
        // archiveClassifier lets us specify that this is an auxilary file (in
        // addition to the main file we're producing, which is a .aar file). It
        // has the effect of adding -sources at the end of the filename.
        archiveClassifier.set("sources")
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }

    // This takes the Javadoc files generated by `javadoc` and bundles them into
    // a single .jar file.
    val javadocJar = tasks.register("javadocJar", Jar::class) {
        // All of this should be self-explanatory from the previous tasks.
        archiveClassifier.set("javadoc")
    }

    // Determine the component to use dynamically
    val component = if (components.findByName("release") != null) {
        components["release"]
    } else {
        components["java"]
    }

    publishing {
        publications {
            // This says: defer this block until all of the other stuff has run first.
            // This is required since components["release"] is generated by the Android
            // plugin in `afterEvaluate` itself, which forces us to do the same.
            afterEvaluate {
                // Create a new publication called "release". The maven-publish plugin
                // creates tasks named publish${name}PublicationTo${target}, where
                // ${name} is a capitalized form of the name and ${target} is an output
                // repository. By default a MavenLocal target is automatically added,
                // which outputs to ~/.m2/repository.
                create<MavenPublication>("release") {
                    // Include all artifacts from the available component component. This is the
                    // .aar file itself.
                    // Include the selected component
                    from(component)

                    // Include the -sources.jar and -javadoc.jar files that we defined earlier.
                    if (includeSources) {
                        artifact(sourcesJar)
                    }
                    artifact(javadocJar)

                    // Here we configure some properties of the publication (these are
                    // automatically applied to the pom file).
                    groupId = groupName
                    artifactId = libraryName
                    version = versionName

                    // And here are some more properties that go into the pom file.
                    pom {
                        packaging = packingOption
                        name.set(project.name)
                        description.set(projectDescription)
                        url.set(projectGithubUrl)
                        licenses {
                            license {
                                name.set("All Rights Reserved")
                                distribution.set("repo")
                            }
                        }
                        developers {
                            developer {
                                id.set(developerId)
                                name.set(developerName)
                                email.set(developerEmail)
                                organization.set(developerOrganisation)
                                organizationUrl.set(developerOrganisationUrl)
                            }
                        }
                        scm {
                            url.set(pom.url.get())
                            connection.set("scm:git:${url.get()}.git")
                            developerConnection.set("scm:git:${url.get()}.git")
                        }
                    }
                }
            }
        }
    }
}